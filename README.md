# The Last Of Guss

## Getting Started

### Prerequisites
- Docker and Docker Compose
- Bun

### Project Setup
1. Start the Docker containers:
```bash
docker-compose up -d
```

2. Create the database schema:
```bash
cd ./back
bun run db
```
or
```bash
cd ./back
npx prisma db push
```

## Project Structure

### Frontend Structure
```
front/
├── src/
│   ├── components/    # Reusable UI components
│   ├── pages/         # Page components
│   ├── states/        # Zustand state management
│   ├── services/      # API and WebSocket services
│   ├── interfaces/    # TypeScript interfaces
│   ├── utils/         # Utility functions
│   └── assets/        # Static assets
├── public/            # Public assets
├── package.json       # Frontend dependencies
└── Dockerfile         # Frontend Docker configuration
```

### Backend Structure
```
back/
├── controllers/       # Fastify route handlers
├── services/          # Business logic
├── repository/        # Database access layer
├── prisma/            # Prisma schema and migrations
├── libs/              # Shared libraries
├── package.json       # Backend dependencies
└── Dockerfile         # Backend Docker configuration
```

## Как это работает
После запуска контейнеров и создании схемы, можно перейти в игру по адресу http://localhost:3000. Первая страница - это форма логина. После ввода имени и пароля и нажатии кнопки входа, отправляется запрос на бекенд, где проверяется наличие пользователя (по имени), если не найдет, то создается новый (с учетом прав "admin" и "Никита"). Так же создается и записывается в куки токен в виде id пользователя, который будет токеном для авторизации. После создания токена, на фронте устанавливается вебсокет соединение.

Далее пользователь попадает на страницу Списка раундов, где отображаются 100 последних раундов. Список обновляется раз в секунду. Если игрок админ, то он может создать раунд. Другие игроки видят новые раунды и могут присоединится. После создания раунда или присоединения к нему, пользователи попадают на страницу раунда, где они уже данные передаются по вебсокету. Сначала запрашивается информация о раунде (id, startTime, endTime, serverTime, stats). Каждые 100 мс идет обновление таймера с учетом оффета по времени (локальная машина, серверное время), чтоб корректно высчитать время начала, кулдауна и конца раунда.

Если раунд находится в активной стадии (время между startTime и endTime) то пользователь может тапать по гусю. На каждый тап отправляется сообщение по вебсокету на бек. На беке через токен пользователя проверяется в каком раунде он сейчас находится (получаем id раунда). Создается транзакция для блокировки записи, в которой проверяется что раунд находится в активной фазе. Далее через upser мы получаем текущие данные по игроку (или создаем), инкрементируем тапы и считаем очки с учетом что каждый 11 тап это 10 очков, так же не забываем про Никиту. Обновляем статистику по игроку и возвращаем очки.

## Чего нет в данной реализации (и обязательно к добавлению на проде)
Нет никакой валидации данных, ни на фронте, ни на беке. Нет никакой защиты пароля (хеширования). Вместо текущей аутентификации надо сделать jwt токены и отдельную таблицу с сессиями, чтоб один игрок не мог сидеть с двух разных устройств. Так же надо отправлять с бека только необходимые данные, а не всю запись. Ну и разные фронтовые улучшения, типа мобильной верстки, может таймер подшаманить в раунде и так далее. Так же была мысль в лобби (список раундов) сделать обновление не раз в секунду, а по сокету, при создании нового раунда (но обновления все равно нужны для смены статуса раунда, но их лучше считать в стейт менеджере).

## Мысли вслух
Выбрал для фронта стейт менеджер Zustand - суперлегкий, супербыстрый, суперудобный. На беке использовать fastify - минималистичный и быстрый, есть все что нужно. Для работы с бд использую Prisma orm, гибкая, быстрая, удобная работа со связями и транзакциями.
Сделал минималистичную схему бд, где не храниться общая сумма очков, где не хранится состояние раунда или победитель, но хранятся все данные чтоб вычислить нужные нам данные. Такой подход позволяет максимально абстрагироваться от бекенда и фронтенда, не усложнять логику отслеживанием состояния раунда и так далее.
